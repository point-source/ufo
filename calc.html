<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>UFO Parametric Cutter (metric)</title>
    <style>
        body {
            font-family: system-ui, Segoe UI, Roboto, Arial;
            margin: 18px;
            color: #111
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 12px;
            max-width: 1200px
        }

        label {
            display: block;
            font-size: 13px;
            margin-bottom: 6px
        }

        input,
        select {
            width: 100%;
            padding: 6px 8px;
            font-size: 14px
        }

        .row {
            margin-bottom: 8px
        }

        .panel {
            border: 1px solid #ddd;
            padding: 12px;
            border-radius: 8px;
            background: #fafafa
        }

        .flex {
            display: flex;
            gap: 12px
        }

        .preview {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 12px
        }

        svg {
            border: 1px solid #ccc;
            background: white;
            width: 100%;
            height: 360px
        }

        .shapes {
            margin-top: 12px
        }

        table {
            width: 100%;
            border-collapse: collapse
        }

        td,
        th {
            padding: 6px;
            border: 1px solid #eee;
            font-size: 13px
        }

        button {
            padding: 8px 12px;
            font-size: 14px
        }

        .small {
            font-size: 12px;
            color: #555
        }
    </style>
</head>

<body>
    <h1>UFO parametric cutter — metric (mm)</h1>
    <p class="small">Interactive single-file generator: enter sizes (mm), adjust panels, and see preview + flat panel
        shapes and counts. Material thickness fixed to 5 mm (foam board) — suitable for hand-fitting and taping.</p>
    <div class="controls panel">
        <div>
            <div class="row"><label>Small diameter (mm) - top cap only</label><input id="smallDiameter" type="number"
                    value="200"></div>
            <div class="row"><label>Main outer diameter (mm) - cone transitions</label><input id="mainOuterDiameter"
                    type="number" value="400"></div>
            <div class="row"><label>Main inner diameter (mm) - cylinder walls</label><input id="mainInnerDiameter"
                    type="number" value="800"></div>
            <div class="row"><label>Total height (mm) - calculated from sections</label><input id="totalHeight"
                    type="number" value="200" readonly></div>
        </div>
        <div>
            <div class="row"><label>Top cone height (mm)</label><input id="topConeHeight" type="number" value="30">
            </div>
            <div class="row"><label>Main upper cone height (mm)</label><input id="mainUpperHeight" type="number"
                    value="40"></div>
            <div class="row"><label>Cylinder height (mm)</label><input id="cylinderHeight" type="number" value="60">
            </div>
            <div class="row"><label>Main lower cone height (mm)</label><input id="mainLowerHeight" type="number"
                    value="40"></div>
        </div>
        <div>
            <div class="row"><label>Material thickness (mm)</label><input id="thickness" type="number" value="5"></div>
            <div class="row"><label>Glue tab width (mm)</label><input id="tabWidth" type="number" value="12"></div>
        </div>
        <div>
            <div class="row"><label>Small-top panel count (N)</label><input id="nSmall" type="number" value="16"
                    min="3"></div>
            <div class="row"><label>Main-ring panel count (N)</label><input id="nMain" type="number" value="32" min="3">
            </div>
            <div class="row"><label>Hole diameter for windows (mm)</label><input id="holeDia" type="number"
                    value="25.4"></div>
            <div class="row"><label>Hole spacing (mm) - minimum center-to-center (auto-fit if 0)</label><input
                    id="holeSpacing" type="number" value="0"></div>
        </div>
    </div>
    <div style="margin-top:12px;display:flex;gap:12px;align-items:center">
        <div class="small">Views update automatically as you change values.</div>
    </div>

    <div class="preview">
        <div class="panel">
            <h3>Top-down</h3>
            <svg id="svgTop" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div class="panel">
            <h3>Side view</h3>
            <svg id="svgSide" viewBox="0 0 1000 400" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div class="panel">
            <h3>3D View</h3>
            <div id="threejs-container" style="width: 100%; height: 400px; border: 1px solid #ccc;"></div>
        </div>
    </div>

    <div class="shapes panel">
        <h3>Unique flat shapes and counts</h3>
        <table>
            <thead>
                <tr>
                    <th>Shape</th>
                    <th>Count</th>
                    <th>Dimensions (mm)</th>
                </tr>
            </thead>
            <tbody id="shapesTable"></tbody>
        </table>
        <p class="small">Each panel includes one glue tab (on one side). The small-top panels are triangular/trapezoid;
            main panels are trapezoids.</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        function mm(n) { return Number(n) }
        function updateTotalHeight() {
            const hTopCone = mm(document.getElementById('topConeHeight').value);
            const hMainUpper = mm(document.getElementById('mainUpperHeight').value);
            const hCylinder = mm(document.getElementById('cylinderHeight').value);
            const hMainLower = mm(document.getElementById('mainLowerHeight').value);
            const totalH = hTopCone + hMainUpper + hCylinder + hMainLower;
            document.getElementById('totalHeight').value = Math.round(totalH);
        }

        function compute() {
            // Get diameter parameters
            const dSmall = mm(document.getElementById('smallDiameter').value);
            const dMainOuter = mm(document.getElementById('mainOuterDiameter').value);
            const dMainInner = mm(document.getElementById('mainInnerDiameter').value);

            // Get section heights
            const hTopCone = mm(document.getElementById('topConeHeight').value);
            const hMainUpper = mm(document.getElementById('mainUpperHeight').value);
            const hCylinder = mm(document.getElementById('cylinderHeight').value);
            const hMainLower = mm(document.getElementById('mainLowerHeight').value);

            // Calculate total height
            const H = hTopCone + hMainUpper + hCylinder + hMainLower;

            const t = mm(document.getElementById('thickness').value);
            const tabW = mm(document.getElementById('tabWidth').value);
            const nSmall = Math.max(3, Math.round(mm(document.getElementById('nSmall').value)));
            const nMain = Math.max(3, Math.round(mm(document.getElementById('nMain').value)));
            const holeDia = mm(document.getElementById('holeDia').value);
            const holeSpacing = mm(document.getElementById('holeSpacing').value);

            // Radii
            const R_small = dSmall / 2;
            const R_mainOuter = dMainOuter / 2;
            const R_mainInner = dMainInner / 2;

            // Calculate panel geometries for each section
            // Top cone: from small diameter to main outer diameter
            const arcSmallTop = (2 * Math.PI * R_small) / nSmall;
            const arcMainOuter = (2 * Math.PI * R_mainOuter) / nSmall;
            const topConePanel = {
                type: 'topCone',
                count: nSmall,
                topWidth: arcSmallTop,
                bottomWidth: arcMainOuter,
                height: hTopCone,
                tabWidth: tabW
            };

            // Main upper cone: from main outer to main inner diameter
            const arcMainOuterUpper = (2 * Math.PI * R_mainOuter) / nMain;
            const arcMainInner = (2 * Math.PI * R_mainInner) / nMain;
            const mainUpperPanel = {
                type: 'mainUpper',
                count: nMain,
                topWidth: arcMainOuterUpper,
                bottomWidth: arcMainInner,
                height: hMainUpper,
                tabWidth: tabW
            };

            // Cylinder: same width top and bottom
            const cylinderPanel = {
                type: 'cylinder',
                count: nMain,
                topWidth: arcMainInner,
                bottomWidth: arcMainInner,
                height: hCylinder,
                tabWidth: tabW
            };

            // Main lower cone: from main inner to main outer diameter
            const mainLowerPanel = {
                type: 'mainLower',
                count: nMain,
                topWidth: arcMainInner,
                bottomWidth: arcMainOuterUpper,
                height: hMainLower,
                tabWidth: tabW
            };

            // Windows: one per cylinder panel, centered in each panel
            let holeCount = 0;
            let windowPositions = [];
            if (holeDia > 0) {
                holeCount = nMain;
                for (let i = 0; i < nMain; i++) {
                    const panelAngle = (2 * Math.PI * i) / nMain;
                    const panelCenterAngle = panelAngle + (Math.PI / nMain);
                    windowPositions.push({
                        angle: panelCenterAngle,
                        radius: R_mainInner,
                        panelIndex: i
                    });
                }
            }

            return {
                H, dSmall, dMainOuter, dMainInner, t, tabW,
                R_small, R_mainOuter, R_mainInner,
                hTopCone, hMainUpper, hCylinder, hMainLower,
                topConePanel, mainUpperPanel, cylinderPanel, mainLowerPanel,
                holeCount, holeDia, windowPositions
            };
        }

        function render() {
            updateTotalHeight();
            const c = compute();
            renderTop(c);
            renderSide(c);
            render3D(c);
            renderShapesTable(c);
        }

        function renderTop(c) {
            const svg = document.getElementById('svgTop');
            clear(svg);
            const W = 1000, H = 1000; const cx = W / 2, cy = H / 2;
            const scale = (W * 0.9) / c.dMainInner;

            // Draw the three main circles
            const mainInnerR = c.R_mainInner * scale;
            const mainOuterR = c.R_mainOuter * scale;
            const smallR = c.R_small * scale;

            // Main inner circle (cylinder section)
            svg.appendChild(circle(cx, cy, mainInnerR, '#e6f3ff', '#bbb', 1));

            // Main outer circle (cone transitions)
            svg.appendChild(circle(cx, cy, mainOuterR, '#f6f6f6', '#bbb', 1));

            // Small top cap
            svg.appendChild(circle(cx, cy, smallR, '#eee', '#bbb', 1));

            // Panel divisions for main sections
            for (let i = 0; i < c.cylinderPanel.count; i++) {
                const a1 = (2 * Math.PI * i) / c.cylinderPanel.count - Math.PI / 2;
                const x1 = cx + Math.cos(a1) * mainInnerR; const y1 = cy + Math.sin(a1) * mainInnerR;
                svg.appendChild(line(cx, cy, x1, y1, '#bbb'));
            }

            // Panel divisions for small sections
            for (let i = 0; i < c.topConePanel.count; i++) {
                const a1 = (2 * Math.PI * i) / c.topConePanel.count - Math.PI / 2;
                const x1 = cx + Math.cos(a1) * smallR; const y1 = cy + Math.sin(a1) * smallR;
                svg.appendChild(line(cx, cy, x1, y1, '#bbb'));
            }

            // Windows at cylinder section
            if (c.windowPositions) {
                for (const window of c.windowPositions) {
                    const x = cx + Math.cos(window.angle - Math.PI / 2) * mainInnerR;
                    const y = cy + Math.sin(window.angle - Math.PI / 2) * mainInnerR;
                    svg.appendChild(circle(x, y, (c.holeDia / 2) * scale, '#fff', 'black', 0.8));
                }
            }

            // Labels
            svg.appendChild(textEl(12, 20, `Main inner Ø = ${c.dMainInner}mm`));
            svg.appendChild(textEl(12, 35, `Main outer Ø = ${c.dMainOuter}mm`));
            svg.appendChild(textEl(12, 50, `Small Ø = ${c.dSmall}mm`));
        }

        function renderSide(c) {
            const svg = document.getElementById('svgSide'); clear(svg);
            const W = 1000, H = 400; const margin = 60;
            const centerX = W / 2;

            // Calculate scaling to fit the UFO profile in the view
            const totalHeight = c.hTopCone + c.hMainUpper + c.hCylinder + c.hMainLower;
            const maxWidth = c.dMainInner; // Full diameter
            const scaleX = (W - 2 * margin) / maxWidth;
            const scaleY = (H - 2 * margin) / totalHeight;

            // Convert radii to screen coordinates
            const rSmall = c.R_small * scaleX;
            const rMainOuter = c.R_mainOuter * scaleX;
            const rMainInner = c.R_mainInner * scaleX;

            // Convert heights to screen coordinates
            const hTopCone = c.hTopCone * scaleY;
            const hMainUpper = c.hMainUpper * scaleY;
            const hCylinder = c.hCylinder * scaleY;
            const hMainLower = c.hMainLower * scaleY;

            // Position from bottom up (correct stacking order)
            const baseY = H - margin;
            const cylinderBottomY = baseY - hMainLower; // Main lower cone ends here
            const cylinderTopY = cylinderBottomY - hCylinder; // Cylinder ends here
            const mainUpperTopY = cylinderTopY - hMainUpper; // Main upper cone ends here
            const topConeTopY = mainUpperTopY - hTopCone; // Top cone ends here

            // Draw main lower cone (trapezoid from main inner to main outer)
            const mainLowerTrapezoid = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            mainLowerTrapezoid.setAttribute('points',
                `${centerX - rMainInner},${cylinderBottomY} ` +
                `${centerX + rMainInner},${cylinderBottomY} ` +
                `${centerX + rMainOuter},${baseY} ` +
                `${centerX - rMainOuter},${baseY}`
            );
            mainLowerTrapezoid.setAttribute('fill', '#f6f6f6');
            mainLowerTrapezoid.setAttribute('stroke', '#bbb');
            mainLowerTrapezoid.setAttribute('stroke-width', '2');
            svg.appendChild(mainLowerTrapezoid);

            // Draw cylinder (rectangle - straight walls)
            const cylinderRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            cylinderRect.setAttribute('x', centerX - rMainInner);
            cylinderRect.setAttribute('y', cylinderTopY);
            cylinderRect.setAttribute('width', rMainInner * 2);
            cylinderRect.setAttribute('height', hCylinder);
            cylinderRect.setAttribute('fill', '#e6f3ff');
            cylinderRect.setAttribute('stroke', '#bbb');
            cylinderRect.setAttribute('stroke-width', '2');
            svg.appendChild(cylinderRect);

            // Draw main upper cone (trapezoid from main outer to main inner)
            const mainUpperTrapezoid = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            mainUpperTrapezoid.setAttribute('points',
                `${centerX - rMainOuter},${mainUpperTopY} ` +
                `${centerX + rMainOuter},${mainUpperTopY} ` +
                `${centerX + rMainInner},${cylinderTopY} ` +
                `${centerX - rMainInner},${cylinderTopY}`
            );
            mainUpperTrapezoid.setAttribute('fill', '#f6f6f6');
            mainUpperTrapezoid.setAttribute('stroke', '#bbb');
            mainUpperTrapezoid.setAttribute('stroke-width', '2');
            svg.appendChild(mainUpperTrapezoid);

            // Draw top cone (trapezoid from small to main outer)
            const topConeTrapezoid = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            topConeTrapezoid.setAttribute('points',
                `${centerX - rSmall},${topConeTopY} ` +
                `${centerX + rSmall},${topConeTopY} ` +
                `${centerX + rMainOuter},${mainUpperTopY} ` +
                `${centerX - rMainOuter},${mainUpperTopY}`
            );
            topConeTrapezoid.setAttribute('fill', '#eee');
            topConeTrapezoid.setAttribute('stroke', '#bbb');
            topConeTrapezoid.setAttribute('stroke-width', '2');
            svg.appendChild(topConeTrapezoid);

            // Add dimension labels
            svg.appendChild(textEl(10, 20, `Side view - Total height: ${c.H}mm`));
            svg.appendChild(textEl(10, 35, `Top: ${c.hTopCone}mm, Upper: ${c.hMainUpper}mm, Cyl: ${c.hCylinder}mm, Lower: ${c.hMainLower}mm`));
        }

        // Three.js 3D rendering
        let scene, camera, renderer, controls;

        function init3D() {
            const container = document.getElementById('threejs-container');
            if (!container) return;

            // Clear existing content
            container.innerHTML = '';

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 80);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Simple orbit controls (mouse interaction)
            controls = {
                mouseX: 0,
                mouseY: 0,
                targetRotationX: 0,
                targetRotationY: 0,
                rotationX: 0,
                rotationY: 0
            };

            // Mouse interaction
            let isMouseDown = false;
            container.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                controls.mouseX = e.clientX;
                controls.mouseY = e.clientY;
            });

            container.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - controls.mouseX;
                    const deltaY = e.clientY - controls.mouseY;
                    controls.targetRotationY += deltaX * 0.01;
                    controls.targetRotationX += deltaY * 0.01;
                    controls.mouseX = e.clientX;
                    controls.mouseY = e.clientY;
                }
            });

            container.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.1;
                camera.position.z = Math.max(30, Math.min(150, camera.position.z));
            });

            // Handle window resize
            function handleResize() {
                const width = container.clientWidth;
                const height = container.clientHeight;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }

            window.addEventListener('resize', handleResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Smooth rotation
                controls.rotationX += (controls.targetRotationX - controls.rotationX) * 0.1;
                controls.rotationY += (controls.targetRotationY - controls.rotationY) * 0.1;

                // Rotate the scene
                scene.rotation.x = controls.rotationX;
                scene.rotation.y = controls.rotationY;

                renderer.render(scene, camera);
            }
            animate();
        }

        function render3D(c) {
            if (!scene) {
                init3D();
            }

            // Clear existing objects
            while (scene.children.length > 0) {
                if (scene.children[0].type === 'AmbientLight' || scene.children[0].type === 'DirectionalLight') {
                    break;
                }
                scene.remove(scene.children[0]);
            }

            // Calculate optimal scale to fit UFO in view
            const maxDimension = Math.max(c.dMainInner, c.H);
            const scale = 0.8 / (maxDimension * 0.01); // Scale to fit 80% of view

            // Auto-position camera to fit the object
            const objectHeight = c.H * scale;
            const objectRadius = c.R_mainInner * scale;
            const optimalDistance = Math.max(objectHeight, objectRadius) * 2.5;
            camera.position.z = Math.max(optimalDistance, 30);
            const material = new THREE.MeshLambertMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.8
            });
            const windowMaterial = new THREE.MeshLambertMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.9
            });

            // Create UFO sections
            const group = new THREE.Group();

            // Main lower cone
            const lowerConeGeometry = new THREE.ConeGeometry(
                c.R_mainOuter * scale,
                c.hMainLower * scale,
                32,
                1,
                true
            );
            const lowerCone = new THREE.Mesh(lowerConeGeometry, material);
            lowerCone.position.y = -c.hMainLower * scale / 2;
            group.add(lowerCone);

            // Cylinder
            const cylinderGeometry = new THREE.CylinderGeometry(
                c.R_mainInner * scale,
                c.R_mainInner * scale,
                c.hCylinder * scale,
                32
            );
            const cylinder = new THREE.Mesh(cylinderGeometry, windowMaterial);
            cylinder.position.y = c.hCylinder * scale / 2;
            group.add(cylinder);

            // Main upper cone
            const upperConeGeometry = new THREE.ConeGeometry(
                c.R_mainOuter * scale,
                c.hMainUpper * scale,
                32,
                1,
                true
            );
            const upperCone = new THREE.Mesh(upperConeGeometry, material);
            upperCone.position.y = c.hCylinder * scale + c.hMainUpper * scale / 2;
            upperCone.rotation.x = Math.PI; // Flip to point up
            group.add(upperCone);

            // Top cone
            const topConeGeometry = new THREE.ConeGeometry(
                c.R_small * scale,
                c.hTopCone * scale,
                32,
                1,
                true
            );
            const topCone = new THREE.Mesh(topConeGeometry, material);
            topCone.position.y = c.hCylinder * scale + c.hMainUpper * scale + c.hTopCone * scale / 2;
            topCone.rotation.x = Math.PI; // Flip to point up
            group.add(topCone);

            // Add windows to cylinder
            if (c.windowPositions && c.windowPositions.length > 0) {
                for (const window of c.windowPositions) {
                    const windowGeometry = new THREE.SphereGeometry(c.holeDia * scale / 2, 16, 16);
                    const windowMesh = new THREE.Mesh(windowGeometry, new THREE.MeshLambertMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.8
                    }));

                    const x = Math.cos(window.angle) * c.R_mainInner * scale;
                    const z = Math.sin(window.angle) * c.R_mainInner * scale;
                    windowMesh.position.set(x, c.hCylinder * scale / 2, z);
                    group.add(windowMesh);
                }
            }

            scene.add(group);
        }

        function renderShapesTable(c) {
            const tbody = document.getElementById('shapesTable'); tbody.innerHTML = '';
            const rows = [];

            // Add all panel types
            rows.push({
                name: 'Top cone panel (trapezoid)',
                count: c.topConePanel.count,
                dim: `top width ${c.topConePanel.topWidth.toFixed(1)} mm × bottom width ${c.topConePanel.bottomWidth.toFixed(1)} mm × height ${c.topConePanel.height} mm (+ tab ${c.topConePanel.tabWidth} mm)`
            });
            rows.push({
                name: 'Main upper cone panel (trapezoid)',
                count: c.mainUpperPanel.count,
                dim: `top width ${c.mainUpperPanel.topWidth.toFixed(1)} mm × bottom width ${c.mainUpperPanel.bottomWidth.toFixed(1)} mm × height ${c.mainUpperPanel.height} mm (+ tab ${c.mainUpperPanel.tabWidth} mm)`
            });
            rows.push({
                name: 'Cylinder panel (rectangle)',
                count: c.cylinderPanel.count,
                dim: `width ${c.cylinderPanel.topWidth.toFixed(1)} mm × height ${c.cylinderPanel.height} mm (+ tab ${c.cylinderPanel.tabWidth} mm)`
            });
            rows.push({
                name: 'Main lower cone panel (trapezoid)',
                count: c.mainLowerPanel.count,
                dim: `top width ${c.mainLowerPanel.topWidth.toFixed(1)} mm × bottom width ${c.mainLowerPanel.bottomWidth.toFixed(1)} mm × height ${c.mainLowerPanel.height} mm (+ tab ${c.mainLowerPanel.tabWidth} mm)`
            });

            if (c.holeCount > 0) {
                rows.push({
                    name: 'Window holes (on cylinder)',
                    count: c.holeCount,
                    dim: `diameter ${c.holeDia} mm around cylinder circumference`
                });
            }

            for (const r of rows) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${r.name}</td><td>${r.count}</td><td>${r.dim}</td>`;
                tbody.appendChild(tr);
            }
        }

        function clear(svg) { while (svg.firstChild) svg.removeChild(svg.firstChild) }
        function circle(cx, cy, r, fill = '#fff', stroke = '#999', opacity = 1) { const el = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); el.setAttribute('cx', cx); el.setAttribute('cy', cy); el.setAttribute('r', r); el.setAttribute('fill', fill); el.setAttribute('stroke', stroke); el.setAttribute('opacity', opacity); return el }
        function line(x1, y1, x2, y2, color) { const l = document.createElementNS('http://www.w3.org/2000/svg', 'line'); l.setAttribute('x1', x1); l.setAttribute('y1', y1); l.setAttribute('x2', x2); l.setAttribute('y2', y2); l.setAttribute('stroke', color); return l }
        function textEl(x, y, text) { const t = document.createElementNS('http://www.w3.org/2000/svg', 'text'); t.setAttribute('x', x); t.setAttribute('y', y); t.setAttribute('font-size', 12); t.setAttribute('fill', '#333'); t.textContent = text; return t }

        // Export basic flat-panel SVG (single combined SVG containing one of each unique shape scaled to view)
        function exportSVG() {
            const c = compute();
            const svgNS = 'http://www.w3.org/2000/svg';
            const doc = document.createElementNS(svgNS, 'svg');
            doc.setAttribute('xmlns', svgNS);
            // create small panel drawing
            const pad = 20; let x = pad, y = pad;
            const sW = Math.max(200, c.smallPanel.bottomWidth + 60);
            const sH = c.smallPanel.height + 60;
            const smallGroup = document.createElementNS(svgNS, 'g');
            const bottomW = c.smallPanel.bottomWidth;
            const h = c.smallPanel.height;
            // small is triangle/trapezoid with top 0
            const points = `${x + sW / 2},${y} ${x + sW},${y + sH} ${x},${y + sH}`;
            const poly = document.createElementNS(svgNS, 'polygon'); poly.setAttribute('points', points); poly.setAttribute('fill', '#fff'); poly.setAttribute('stroke', '#000'); smallGroup.appendChild(poly);
            // tab on right
            const tab = document.createElementNS(svgNS, 'rect'); tab.setAttribute('x', x + sW + 2); tab.setAttribute('y', y + sH / 2 - c.smallPanel.tabWidth / 2); tab.setAttribute('width', c.smallPanel.tabWidth); tab.setAttribute('height', c.smallPanel.tabWidth * 1.8); tab.setAttribute('fill', '#fff'); tab.setAttribute('stroke', '#000'); smallGroup.appendChild(tab);
            doc.appendChild(smallGroup);

            // main panel
            x += sW + pad;
            const mainGroup = document.createElementNS(svgNS, 'g');
            const topW = c.mainPanel.topWidth; const botW = c.mainPanel.bottomWidth; const mh = c.mainPanel.height;
            const points2 = `${x + (sW / 2 - topW / 2)},${y} ${x + (sW / 2 + topW / 2)},${y} ${x + (sW / 2 + botW / 2)},${y + mh} ${x + (sW / 2 - botW / 2)},${y + mh}`;
            const poly2 = document.createElementNS(svgNS, 'polygon'); poly2.setAttribute('points', points2); poly2.setAttribute('fill', '#fff'); poly2.setAttribute('stroke', '#000'); mainGroup.appendChild(poly2);
            // tab
            const tab2 = document.createElementNS(svgNS, 'rect'); tab2.setAttribute('x', x + sW / 2 + botW / 2 + 2); tab2.setAttribute('y', y + mh / 2 - c.mainPanel.tabWidth / 2); tab2.setAttribute('width', c.mainPanel.tabWidth); tab2.setAttribute('height', c.mainPanel.tabWidth * 2); tab2.setAttribute('fill', '#fff'); tab2.setAttribute('stroke', '#000'); mainGroup.appendChild(tab2);
            doc.appendChild(mainGroup);

            // serialize and trigger download
            const serializer = new XMLSerializer(); const str = serializer.serializeToString(doc);
            const blob = new Blob([str], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'ufo_panels.svg'; document.body.appendChild(a); a.click(); a.remove();
        }

        // live updates
        // Auto-update on all parameter changes
        const allInputs = ['smallDiameter', 'mainOuterDiameter', 'mainInnerDiameter', 'topConeHeight', 'mainUpperHeight', 'cylinderHeight', 'mainLowerHeight', 'thickness', 'tabWidth', 'nSmall', 'nMain', 'holeDia', 'holeSpacing'];
        allInputs.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('input', render);
                element.addEventListener('change', render);
            }
        });
        // initial
        render();
    </script>
</body>

</html>